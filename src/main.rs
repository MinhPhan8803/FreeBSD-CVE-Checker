use std::string;
use rusqlite;
//use std::env;
use version_compare::Version;
use quick_xml::{Reader, events::Event};
use std::rc::Rc;
struct CVE {
    package_name: Rc<str>,
    cve_id: String,
    cve_description: String,
    package_version_upper: Rc<UpperBound>,
    package_version_lower: Rc<LowerBound>,
}
struct Package {
    name: String,
    version: String
}

enum LowerBound {
    Ge(String),
    Gt(String)
}
enum UpperBound {
    Le(String),
    Lt(String)
}

fn main() {
    //env::set_var("RUST_BACKTRACE", "1");
    let messages = compare_cves_to_packages();
    println!("{} security problems detected", messages.len());
    for message in messages {
        println!("{}", message);
    }
}

// Parse vuln.xml, StAX implementation
fn parse_cve_xml_stax() -> Vec<CVE> {
    // /var/db/pkg/vuln.xml
    let mut reader = Reader::from_file("actualfiles\\vuln.xml")
    .expect("vuln.xml not found");
    reader.trim_text(true);
    let mut cve_vec = Vec::new();

    let mut names: Vec<Rc<str>> = Vec::new();
    let mut overall_cve: String = String::new();
    let mut overall_description: String = String::new();
    let mut versions_lower: Vec<Rc<LowerBound>> = Vec::new();
    let mut versions_upper: Vec<Rc<UpperBound>> = Vec::new();

    let mut has_lower = false;
    let mut node_name = "";
    let mut buf = Vec::new();

    let mut single_vuln_names: Vec<Rc<str>> = Vec::new();
    let mut single_vuln_vers_lower: Vec<Rc<LowerBound>> = Vec::new();
    let mut single_vuln_vers_upper: Vec<Rc<UpperBound>> = Vec::new();

    let default_upper = Rc::new(UpperBound::Lt("9999.9999.9999".to_string()));
    let default_lower = Rc::new(LowerBound::Ge("0.0.0".to_string()));
    // Loop through XML events
    loop {
        match reader.read_event(&mut buf) {
            Ok(Event::Eof) => break,

            // End of current vuln
            Ok(Event::End(e)) => {
                node_name = "";
                if e.name() == b"vuln" {
                    while single_vuln_vers_lower.len() > single_vuln_vers_upper.len() {
                        single_vuln_vers_upper.push(default_upper.clone());
                    }

                    for name in &single_vuln_names {
                        for ver_count in 0..single_vuln_vers_lower.len() {
                            names.push(name.clone());
                            versions_lower.push(single_vuln_vers_lower[ver_count].clone());
                            versions_upper.push(single_vuln_vers_upper[ver_count].clone());
                        }
                    }

                    //Create CVE objects
                    while !names.is_empty() {
                        let name = names.swap_remove(0);
                        let version_upper = versions_upper.swap_remove(0);
                        let version_lower = versions_lower.swap_remove(0);
                        cve_vec.push(CVE { package_name: name, cve_id: overall_cve.clone(),
                            cve_description: overall_description.clone(), package_version_upper: version_upper,
                            package_version_lower: version_lower});
                    }

                    has_lower = false;
                    overall_cve.clear();
                    overall_description.clear();
                    single_vuln_names.clear();
                    single_vuln_vers_lower.clear();
                    single_vuln_vers_upper.clear();
                }
            }

            // Start node events, see which type of node it is
            Ok(Event::Start(e)) => match e.name() {
                b"name" => node_name = "name",
                b"eq" => node_name = "eq",
                b"ge" => node_name = "ge",
                b"gt" => node_name = "gt",
                b"lt" => node_name = "lt",
                b"le" => node_name = "le",
                b"cvename" => node_name = "cvename",
                b"blockquote" => node_name = "blockquote",
                b"p" => node_name = "p",
                b"h1" => node_name = "h1",
                b"li" => node_name = "li",
                _ => node_name = ""
            }

            // If text event, check text and current node
            Ok(Event::Text(e)) => match node_name {

// ----------------------- CHECK NAME AND VER --------------------------//
                // Assume the following node order: <name> -> <ge>/<gt> -> <lt>/<le> -> repeat
                "name" => {

                    let name = Rc::from(reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered"));

                    // If there is no version data yet, it means this is the first name in a vuln,
                    // or part of a chain of names. If there is, then this is the start of a new chain,
                    // and so the last chain is concluded and put into the overall vuln vectors
                    if !single_vuln_vers_lower.is_empty() {
                        // Handles the case where <lt>/<le> dont exist
                        while single_vuln_vers_lower.len() > single_vuln_vers_upper.len() {
                            single_vuln_vers_upper.push(default_upper.clone());
                        }
    
                        for name in &single_vuln_names {
                            for ver_count in 0..single_vuln_vers_lower.len() {
                                names.push(name.clone());
                                versions_lower.push(single_vuln_vers_lower[ver_count].clone());
                                versions_upper.push(single_vuln_vers_upper[ver_count].clone());
                            }
                        }
                        single_vuln_names.clear();
                        single_vuln_vers_lower.clear();
                        single_vuln_vers_upper.clear();
                    }

                    single_vuln_names.push(name);
                    has_lower = false;
                },

                // Assume that <ge>/<gt>, if exists, always come before <le>/<lt>
                "ge" | "gt" => {
                    has_lower = true;
                    let text = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();

                    let version = match node_name {
                        "ge" => Rc::new(LowerBound::Ge(text)),
                        _ => Rc::new(LowerBound::Gt(text)),
                    };
                    single_vuln_vers_lower.push(version);
                },

                // Also handles <ge>/<gt> if it doesnt exist, therefore length of 
                // lower vector always >= upper vector
                "lt" | "le" => {
                    let text = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();

                    let version = match node_name {
                        "lt" => Rc::new(UpperBound::Lt(text)),
                        _ => Rc::new(UpperBound::Le(text))
                    };
                    while single_vuln_vers_lower.len() - single_vuln_vers_upper.len() > 1 {
                        single_vuln_vers_upper.push(default_upper.clone());
                    }

                    single_vuln_vers_upper.push(version);
                    if !has_lower {
                        single_vuln_vers_lower.push(default_lower.clone());
                    }
                    has_lower = false;
                },

                //Also handles <ge>/<gt> if it doesnt exist
                // <eq> is treated as a <ge> <le> pair
                "eq" => {
                    while single_vuln_vers_lower.len() > single_vuln_vers_upper.len() {
                        single_vuln_vers_upper.push(default_upper.clone())
                    }

                    let text = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();
                    let ver_low = Rc::new(LowerBound::Ge(text.clone()));
                    let ver_up = Rc::new(UpperBound::Le(text));

                    single_vuln_vers_lower.push(ver_low);
                    single_vuln_vers_upper.push(ver_up);

                    has_lower = false;
                },

//---------------------- CHECK CVE NAME AND DESC ------------------------//
                "cvename" => {
                    let cve = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();
                    overall_cve += &(cve + "\n");
                },

                // Source description
                "blockquote" => {
                    let source = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered");
                    overall_description += &("Source: ".to_owned() + source + "\n");
                },

                // Actual description
                "p" | "h1" | "li" => {
                    overall_description += &(reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string() + "\n");
                },
                _ => ()
            }
            _ => ()
        }
        buf.clear();
    }
    cve_vec
}

// Query local.sqlite to get local package names and versions
fn query_local_packages() -> Vec<Package> { 
    //  /var/db/pkg/local.sqlite

    let connection: rusqlite::Connection = rusqlite::Connection
    ::open("actualfiles\\local.sqlite")
    .expect("local.sqlite not found");

    let mut query: rusqlite::Statement = connection
    .prepare("SELECT name, version FROM packages;")
    .expect("\"name\" or \"version\" column not found in local.sqlite");

    // Lambda returning an iterator over (name, version) tuples
    let cve_iter = query.query_map([], |row| {
        let name: String = row.get_unwrap(0);
        let version: String = row.get_unwrap(1);
        Ok(Package {name, version})
    }).expect("\"name\" or \"version\" column parse failed");

    let package_vec: Vec<Package> = cve_iter
    .map(|f: Result<Package, rusqlite::Error>| f.expect("Invalid entry in local.sqlite"))
    .collect();
    package_vec
}

// Match packages against cves
fn compare_cves_to_packages() -> Vec<string::String> {
    let mut messages = Vec::new();

    let mut cves: Vec<CVE> = parse_cve_xml_stax();
    cves.sort_unstable_by(|a, b| a.package_name.cmp(&b.package_name));

    let local_packages: Vec<Package> = query_local_packages();

    // Check package names and versions
    // Version checking assumes that version naming scheme is consistent across a package,
    // any edge cases will need to be handled manually
    for local_package in local_packages {
        let mut head: usize = 0;
        let mut tail: usize = cves.len() - 1;

        // Use binary search to look through the list of CVEs. 
        // Appr 13000 entries in the entire xml file -> cut down to about 14 steps
        while head <= tail {

            let middle: usize = (tail + head)/2;
            let cve = &cves[middle];

            if *cve.package_name > *local_package.name {
                tail = middle - 1;
            } else if *cve.package_name < *local_package.name {
                head = middle + 1;
            } else {
                make_message(&cve, &local_package, &mut messages);
                let mut forward: usize = middle + 1;
                let mut backward: usize = middle - 1;
                while forward < cves.len() {
                    if *(&cves[forward]).package_name == *local_package.name {
                        println!("{}", forward);
                        make_message(&cves[forward], &local_package, &mut messages);
                        forward += 1;
                    } else {
                        break;
                    }
                }
                // This check is technically redundant as type usize is >=0 but it is kept
                // for readability
                while backward >= 0 {
                    if *(&cves[backward]).package_name == *local_package.name {
                        println!("{}", backward);
                        make_message(&cves[backward], &local_package, &mut messages);
                        backward -= 1;
                    } else {
                        break;
                    }
                }
                break;
            }
        }
    }
    messages
}

fn make_message(cve: &CVE, local_package: &Package, messages: &mut Vec<String>) {
    let current: Version = Version::from(&local_package.version).unwrap();
    let upper_bound = &*cve.package_version_upper;
    let lower_bound = &*cve.package_version_lower;
    let mut upper_bound_satisfied = false;
    let mut lower_bound_satisfied = false;
    let text_upper: String;
    let text_lower: String;

    match upper_bound {
        UpperBound::Lt(ver) => {
            let upper_version: Version = Version::from(&ver).unwrap();
            text_upper = format!("vuln affects versions earlier than = {}", ver);
            if current < upper_version {
                upper_bound_satisfied = true;
            }
            if &*cve.package_name == "xorg-server" && upper_version >= Version::from("6.7.0").unwrap() {
                upper_bound_satisfied = false;
            }
        }
        UpperBound::Le(ver) => {
            let upper_version: Version = Version::from(&ver).unwrap();
            text_upper = format!("vuln affects versions earlier or equal to = {}", ver);
            if current <= upper_version {
                upper_bound_satisfied = true;
            }
        }
    };

    match lower_bound {
        LowerBound::Gt(ver) => {
            let lower_version: Version = Version::from(&ver).unwrap();
            text_lower = format!("vuln affects versions later than = {}", ver);
            if current > lower_version {
                lower_bound_satisfied = true;
            }
        }
        LowerBound::Ge(ver) => {
            let lower_version: Version = Version::from(&ver).unwrap();
            text_lower = format!("vuln affects versions later or equal to = {}", ver);
            if current >= lower_version {
                lower_bound_satisfied = true;
            }
        }
    };

    if upper_bound_satisfied && lower_bound_satisfied {
        messages.push(format!("
        id = {}
        package = {}
        description = {}
        local version = {}
        {}
        {}
        ", cve.cve_id, cve.package_name, cve.cve_description, local_package.version,
        text_upper, text_lower));
    }
}

