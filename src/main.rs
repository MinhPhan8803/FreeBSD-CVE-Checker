use std::fs;
use std::string;
use roxmltree;
use roxmltree::ParsingOptions;
use rusqlite;
use std::env;
use version_compare::Version;
struct CVE {
    package_name: String,
    cve_id: String,
    cve_description: String,
    package_version_lt: String,
    package_version_ge: String,
}
fn main() {
    env::set_var("RUST_BACKTRACE", "1");
    let messages = compare_cves_to_packages();
    println!("{} security problems detected", messages.len().to_string());
    for message in messages {
        println!("{}", message);
    }
}

// Parse vuln.xml
fn parse_cve_xml() -> Vec<CVE> {  
    // /var/db/pkg/vuln.xml
    let xml_string: String = fs::read_to_string("/var/db/pkg/vuln.xml")
    .expect("vuln.xml not found");

    let mut parse_option: ParsingOptions = roxmltree::ParsingOptions::default();
    parse_option.allow_dtd = true;

    let vuln_document: roxmltree::Document = roxmltree::Document
    ::parse_with_options(xml_string.as_str(), parse_option)
    .expect("Invalid XML in vuln.xml");

    check_xml_document(vuln_document)
}

// Check document nodes and their tag names
fn check_xml_document(vuln_document: roxmltree::Document) -> Vec<CVE> {
    let mut cve_vec = Vec::new();

    for vuln_entry in vuln_document.root_element().children() {
        let mut names: Vec<string::String> = Vec::new();
        let mut overall_cve = String::new();
        let mut overall_description = String::new();
        let mut versions_ge: Vec<string::String> = Vec::new();
        let mut versions_lt: Vec<string::String> = Vec::new();
        let mut has_ge = false;

        // Giant block to iterate nodes
        for inner_node in vuln_entry.descendants() {

// ----------------------- CHECK NAME AND VER --------------------------//

            // Assume the following node order: <name> -> <ge> -> <lt> -> repeat
            if inner_node.has_tag_name("name") {
                names.push(inner_node.text().unwrap().to_string());

                // Handles the case where <lt> doesnt exist
                while versions_ge.len() > versions_lt.len() {
                    versions_lt.push("9999.9999.9999".to_string());
                    has_ge = false;
                }
            }

            // Tag used with a single package in vuln.xml
            if inner_node.has_tag_name("eq") {
                versions_ge.push("".to_string());
                versions_lt.push(inner_node.text().unwrap().to_string());
            }

            // Both if{} blocks below dont handle the case of M:N relationship between versions
            // and packages prior to repeat yet, will probably require some refactoring to fit that

            // Assume that <ge>, if exists, always come before <lt>
            if inner_node.has_tag_name("ge") {
                has_ge = true;
                // M version ranges - 1 package
                if names.len() == versions_ge.len() {
                    names.push(names.last().unwrap().to_string());
                    versions_ge.push(inner_node.text().unwrap().to_string());
                }
                // 1 version range - N packages
                while versions_ge.len() < names.len() {
                    versions_ge.push(inner_node.text().unwrap().to_string());
                }
            }

            // Also handles <ge> if it doesnt exist, therefore length of 
            // ge vector always >= lt vector
            if inner_node.has_tag_name("lt") || inner_node.has_tag_name("le") { 
                if names.len() == versions_lt.len() {
                    names.push(names.last().unwrap().to_string());
                    versions_lt.push(inner_node.text().unwrap().to_string());
                    if !has_ge {
                        versions_ge.push("0.0.0".to_string());
                    }
                }
                while versions_lt.len() < names.len() {
                    versions_lt.push(inner_node.text().unwrap().to_string());
                    if !has_ge {
                        versions_ge.push("0.0.0".to_string());
                    }
                }
                has_ge = false;
            }

//---------------------- CHECK CVE NAME AND DESC ------------------------//

            // <cvename>, also return the function when the loop went back too far
            if inner_node.has_tag_name("cvename") {
                let cve = inner_node.text().unwrap().to_string();
                if cve[4..8] < *"2018" {
                    return cve_vec;
                }
                overall_cve += &(cve + "\n");
            }

            // Source description
            if inner_node.has_tag_name("blockquote") && inner_node.attribute("cite").is_some() {
                let source = inner_node.attribute("cite").unwrap();
                overall_description += &("Source: ".to_owned() + source + "\n");
            }

            // Actual description
            if inner_node.has_tag_name("p") && inner_node.text().is_some() {
                overall_description += &(inner_node.text().unwrap().to_string() + "\n");
                for desc_node in inner_node.descendants() {
                    if desc_node.is_text() {
                        overall_description += &(desc_node.text().unwrap().to_string() + "\n");
                    }
                }
            }
        }

        // Create CVE objects
        while !names.is_empty() {
            let name = names.swap_remove(0);
            let version_lt = versions_lt.swap_remove(0);
            let version_ge = versions_ge.swap_remove(0);
            cve_vec.push(CVE { package_name: name, cve_id: overall_cve.clone(),
                 cve_description: overall_description.clone(), package_version_ge: version_ge,
                package_version_lt: version_lt});
        }
    }
    cve_vec
}

// Query local.sqlite to get local package names and versions
fn query_local_packages() -> Vec<(string::String, string::String)> { 
    //  /var/db/pkg/local.sqlite
    let mut package_vec = Vec::new();

    let connection: rusqlite::Connection = rusqlite::Connection
    ::open("/var/db/pkg/local.sqlite")
    .expect("local.sqlite not found");

    let mut query: rusqlite::Statement = connection
    .prepare("SELECT name, version FROM packages;")
    .expect("\"name\" or \"version\" column not found in local.sqlite");

    // Lambda returning an iterator over (name, version) tuples
    let cve_iter = query.query_map([], |row| {
        let name: String = row.get_unwrap(0);
        let version: String = row.get_unwrap(1);
        Ok((name, version))
    }).expect("\"name\" or \"version\" column parse failed");

    for cve in cve_iter {
        package_vec.push(cve.expect("Invalid entry in local.sqlite"));
    }
    package_vec
}

// Match packages against cves
fn compare_cves_to_packages() -> Vec<string::String> {
    let mut messages = Vec::new();

    let mut cves = parse_cve_xml();
    cves.sort_unstable_by(|a, b| a.package_name.cmp(&b.package_name));

    let local_packages = query_local_packages();

    // Check package names and versions
    // Version checking assumes that version naming scheme is consistent across a package
    for local_package in local_packages {
        for cve in &cves {
            if cve.package_name > local_package.0 {
                break;
            }
            if cve.package_name == local_package.0 {
                let current: Version = Version::from(&local_package.1).unwrap();
                let lt: Version = Version::from(&cve.package_version_lt).unwrap();
                let ge: Version = Version::from(&cve.package_version_ge).unwrap();
                if current < lt && current >= ge {
                    messages.push(format!("
                    id = {}
                    package = {}
                    description = {}
                    local version = {}
                    vuln affects versions later or equal to = {}
                    vuln affects versions earlier than = {}
                    ", cve.cve_id, cve.package_name, cve.cve_description, local_package.1,
                    cve.package_version_ge, cve.package_version_lt));
                }
            }
        }
    }
    messages
}

// Unit tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xml_parse() {
        //assert_eq!(parse_cve_xml().len(),3);
        //assert_eq!(parse_cve_xml()[0].package_version, "0.13.0".to_string());
        //assert_eq!(parse_cve_xml()[1].package_version, "14.10.5".to_string());
        //assert_eq!(parse_cve_xml()[2].package_version, "14.20.0".to_string());
    }

    #[test]
    fn test_sqlite_query() {
        //assert!(query_local_packages().contains(&(pkg).to_string()));
        //assert!(query_local_packages().contains(&"lynx".to_string()));
        //assert!(query_local_packages().contains(&"readline".to_string()));
        //assert_eq!(query_local_packages().len(), 3);
    }

    #[test]
    fn test_matching() {
        //assert_eq!(compare_cves_to_packages().len(), 2);
    }
}
