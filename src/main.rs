use std::string;
use rusqlite;
use std::env;
use version_compare::Version;
use quick_xml::{Reader, events::Event};
struct CVE {
    package_name: String,
    cve_id: String,
    cve_description: String,
    package_version_upper: (String, UpperBound),
    package_version_lower: (String, LowerBound),
}
#[derive(PartialEq, Clone)]
enum LowerBound {
    ge,
    gt
}
#[derive(PartialEq, Clone)]
enum UpperBound {
    le,
    lt
}

fn main() {
    env::set_var("RUST_BACKTRACE", "1");
    let messages = compare_cves_to_packages();
    println!("{} security problems detected", messages.len().to_string());
    for message in messages {
        println!("{}", message);
    }
}

// Parse vuln.xml, StAX implementation
fn parse_cve_xml_stax() -> Vec<CVE> {
    // /var/db/pkg/vuln.xml
    let mut reader = Reader::from_file("actualfiles\\vuln.xml")
    .expect("vuln.xml not found");
    reader.trim_text(true);
    let mut cve_vec = Vec::new();

    let mut names: Vec<string::String> = Vec::new();
    let mut overall_cve: string::String = String::new();
    let mut overall_description: string::String = String::new();
    let mut versions_lower: Vec<(string::String, LowerBound)> = Vec::new();
    let mut versions_upper: Vec<(string::String, UpperBound)> = Vec::new();
    let mut has_lower = false;
    let mut node_name = "";
    let mut buf = Vec::new();
    
    // Loop through XML events
    loop {
        match reader.read_event(&mut buf) {
            Ok(Event::Eof) => break,

            // End of current vuln
            Ok(Event::End(e)) => {
                node_name = "";
                if e.name() == b"vuln" {
                    while versions_lower.len() > versions_upper.len() {
                        versions_upper.push(("9999.9999.9999".to_string(), UpperBound::lt));
                    }
                    //Create CVE objects
                    while !names.is_empty() {
                        let name = names.swap_remove(0);
                        let version_upper = versions_upper.swap_remove(0);
                        let version_lower = versions_lower.swap_remove(0);
                        cve_vec.push(CVE { package_name: name, cve_id: overall_cve.clone(),
                            cve_description: overall_description.clone(), package_version_upper: version_upper,
                            package_version_lower: version_lower});
                    }

                    has_lower = false;
                    names.clear();
                    versions_lower.clear();
                    versions_upper.clear();
                    overall_cve.clear();
                    overall_description.clear();
                }
            }

            // 
            Ok(Event::Start(e)) => match e.name() {
                b"name" => node_name = "name",
                b"eq" => node_name = "eq",
                b"ge" => node_name = "ge",
                b"gt" => node_name = "gt",
                b"lt" => node_name = "lt",
                b"le" => node_name = "le",
                b"cvename" => node_name = "cvename",
                b"blockquote" => node_name = "blockquote",
                b"p" => node_name = "p",
                b"h1" => node_name = "h1",
                b"li" => node_name = "li",
                _ => node_name = ""
            }

            // If text event, check text and current node
            Ok(Event::Text(e)) => match node_name {

// ----------------------- CHECK NAME AND VER --------------------------//
                // Assume the following node order: <name> -> <ge>/<gt> -> <lt>/<le> -> repeat
                "name" => {
                    names.push(reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string());
                    // Handles the case where <lt> doesnt exist
                    while versions_lower.len() > versions_upper.len() {
                        versions_upper.push(("9999.9999.9999".to_string(), UpperBound::lt));
                        has_lower = false;
                    }
                },

                // Both if{} blocks below dont handle the case of M:N relationship between versions
                // and packages prior to repeat yet, will probably require some refactoring to fit that.
                // Assume that <ge>/<gt>, if exists, always come before <le>/<lt>
                "ge" | "gt" => {
                    has_lower = true;
                    let text = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();
                    let enum_type = if node_name == "ge" {
                        LowerBound::ge
                    } else {
                        LowerBound::gt
                    };
                    // M version ranges - 1 package
                    if  names.len() == versions_lower.len() {
                        let latest_name = names.last().unwrap().to_string();
                        names.push(latest_name);
                        versions_lower.push((text.clone(), enum_type.clone()));
                    }
                    // 1 version range - N packages
                    while versions_lower.len() < names.len() {
                        versions_lower.push((text.clone(), enum_type.clone()));
                    }
                },

                // Also handles <ge>/<gt> if it doesnt exist, therefore length of 
                // lower vector always >= upper vector
                "lt" | "le" => {
                    let text = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();
                    let enum_type = if node_name == "lt" {
                        UpperBound::lt
                    } else {
                        UpperBound::le
                    };
                    if  names.len() == versions_upper.len() {
                        let latest_name = names.last().unwrap().to_string();
                        names.push(latest_name);
                        versions_upper.push((text.clone(), enum_type.clone()));
                        if !has_lower {
                            versions_lower.push(("0.0.0".to_string(), LowerBound::ge));
                        }
                    }
                    while versions_upper.len() < names.len() {
                        versions_upper.push((text.clone(), enum_type.clone()));
                        if !has_lower {
                            versions_lower.push(("0.0.0".to_string(), LowerBound::ge));
                        }
                    }
                    has_lower = false;
                },

                // Tag used with a single package in vuln.xml
                "eq" => {
                    let text = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();
                    versions_lower.push((text.clone(), LowerBound::ge));
                    versions_upper.push((text, UpperBound::le));
                },

//---------------------- CHECK CVE NAME AND DESC ------------------------//
                // <cvename>, also return the function when the loop went back too far
                "cvename" => {
                    let cve = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string();
                    if cve[4..8] < *"2008" {
                        return cve_vec;
                    }
                    overall_cve += &(cve + "\n");
                },

                // Source description
                "blockquote" => {
                    let source = reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered");
                    overall_description += &("Source: ".to_owned() + source + "\n");
                },

                // Actual description
                "p" | "h1" | "li" => {
                    overall_description += &(reader.decode(e.escaped())
                    .expect("Non UTF8 string encountered").to_string() + "\n");
                },
                _ => ()
            }
            _ => ()
        }
        buf.clear();
    }
    cve_vec
}

// Query local.sqlite to get local package names and versions
fn query_local_packages() -> Vec<(string::String, string::String)> { 
    //  /var/db/pkg/local.sqlite
    let mut package_vec = Vec::new();

    let connection: rusqlite::Connection = rusqlite::Connection
    ::open("actualfiles\\local.sqlite")
    .expect("local.sqlite not found");

    let mut query: rusqlite::Statement = connection
    .prepare("SELECT name, version FROM packages;")
    .expect("\"name\" or \"version\" column not found in local.sqlite");

    // Lambda returning an iterator over (name, version) tuples
    let cve_iter = query.query_map([], |row| {
        let name: String = row.get_unwrap(0);
        let version: String = row.get_unwrap(1);
        Ok((name, version))
    }).expect("\"name\" or \"version\" column parse failed");

    for cve in cve_iter {
        package_vec.push(cve.expect("Invalid entry in local.sqlite"));
    }
    package_vec
}

// Match packages against cves
fn compare_cves_to_packages() -> Vec<string::String> {
    let mut messages = Vec::new();

    let mut cves = parse_cve_xml_stax();
    cves.sort_unstable_by(|a, b| a.package_name.cmp(&b.package_name));

    let local_packages = query_local_packages();

    // Check package names and versions
    // Version checking assumes that version naming scheme is consistent across a package
    for local_package in local_packages {
        for cve in &cves {
            if cve.package_name > local_package.0 {
                break;
            }
            if cve.package_name == local_package.0 {
                let current: Version = Version::from(&local_package.1).unwrap();
                let upper_bound = &cve.package_version_upper;
                let lower_bound = &cve.package_version_lower;
                let upper_version: Version = Version::from(&(upper_bound).0).unwrap();
                let lower_version: Version = Version::from(&(lower_bound).0).unwrap();

                let text_upper = if upper_bound.1 == UpperBound::lt {
                    format!("vuln affects versions earlier than = {}", upper_bound.0)
                } else {
                    format!("vuln affects versions earlier or equal to = {}", upper_bound.0)
                };

                let text_lower = if lower_bound.1 == LowerBound::gt {
                    format!("vuln affects versions later than = {}", upper_bound.0)
                } else {
                    format!("vuln affects versions later or equal to = {}", upper_bound.0)
                };

                if ((upper_bound.1 == UpperBound::lt && current < upper_version) 
                || (upper_bound.1 == UpperBound::le && current <= upper_version)) &&
                ((lower_bound.1 == LowerBound::gt && current > lower_version) 
                || (lower_bound.1 == LowerBound::ge && current >= upper_version)) {
                    messages.push(format!("
                    id = {}
                    package = {}
                    description = {}
                    local version = {}
                    {}
                    {}
                    ", cve.cve_id, cve.package_name, cve.cve_description, local_package.1,
                    text_upper, text_lower));
                }
           }
        }
    }
    messages
}

// Unit tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xml_parse() {
        //assert_eq!(parse_cve_xml().len(),3);
        //assert_eq!(parse_cve_xml()[0].package_version, "0.13.0".to_string());
        //assert_eq!(parse_cve_xml()[1].package_version, "14.10.5".to_string());
        //assert_eq!(parse_cve_xml()[2].package_version, "14.20.0".to_string());
    }

    #[test]
    fn test_sqlite_query() {
        //assert!(query_local_packages().contains(&(pkg).to_string()));
        //assert!(query_local_packages().contains(&"lynx".to_string()));
        //assert!(query_local_packages().contains(&"readline".to_string()));
        //assert_eq!(query_local_packages().len(), 3);
    }

    #[test]
    fn test_matching() {
        //assert_eq!(compare_cves_to_packages().len(), 2);
    }
}
